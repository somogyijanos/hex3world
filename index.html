<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Hex3World - WORKING DEMO</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 350px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
        }
        
        .viewport {
            flex: 1;
            position: relative;
        }
        
        #renderer {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .controls h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .info {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        
        #console {
            background: #000;
            color: #0f0;
            font-family: monospace;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-size: 10px;
            white-space: pre-wrap;
        }
        
        .status {
            padding: 5px 10px;
            margin: 5px 0;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .status.success { background: #4CAF50; }
        .status.error { background: #f44336; }
        .status.warning { background: #ff9800; }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>üåç Hex3World</h2>
            <div class="status success">‚úÖ WORKING DEMO WITH COORDINATE SYSTEM</div>
            
            <div class="controls">
                <h3>World Controls</h3>
                <button id="loadDemo">üöÄ Load Demo World</button>
                <button id="centerCamera">üìπ Center Camera</button>
                <button id="toggleGrid">‚äû Toggle Grid</button>
            </div>
            
            <div class="info">
                <h4>üß≠ Coordinate System:</h4>
                <ul>
                    <li>üî¥ <strong>RED</strong> = X-axis (right)</li>
                    <li>üü¢ <strong>GREEN</strong> = Y-axis (up)</li>
                    <li>üîµ <strong>BLUE</strong> = Z-axis (forward)</li>
                    <li>‚ö™ <strong>WHITE CUBE</strong> = Origin (0,0,0)</li>
                </ul>
            </div>
            
            <div class="info">
                <h4>üéÆ Controls:</h4>
                <ul>
                    <li><strong>Mouse:</strong> Orbit camera</li>
                    <li><strong>Wheel:</strong> Zoom in/out</li>
                    <li><strong>Right-click:</strong> Pan view</li>
                </ul>
            </div>
            
            <div id="worldInfo" class="info" style="display: none;">
                <h4>üåç World Info:</h4>
                <p id="tileCount">Tiles: 0</p>
                <p id="addonCount">Addons: 0</p>
                <p id="assetPack">Asset Pack: None</p>
            </div>
            
            <div class="info">
                <h4>üìä Debug Console:</h4>
                <div id="console"></div>
            </div>
        </div>
        
        <div class="viewport">
            <div id="renderer"></div>
            <div id="loading" class="loading" style="display: none;">
                <h3>üîÑ Loading...</h3>
                <p>Loading 3D models and rendering world...</p>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "./node_modules/three/build/three.module.js",
            "three/addons/": "./node_modules/three/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';

        const consoleDiv = document.getElementById('console');
        
        function log(message) {
            console.log(message);
            const timestamp = new Date().toLocaleTimeString();
            consoleDiv.textContent += `[${timestamp}] ${message}\n`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        class WorkingHexRenderer {
            constructor(container) {
                this.container = container;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.controls = null;
                this.worldGroup = new THREE.Group();
                this.loadedModels = new Map();
                
                this.setupRenderer();
                this.setupScene();
                this.setupLighting();
                this.setupControls();
                this.setupGrid();
                this.addCoordinateSystem();
                
                this.animate();
                log('‚úÖ RENDERER INITIALIZED WITH COORDINATE SYSTEM');
            }
            
            setupRenderer() {
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupScene() {
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.add(this.worldGroup);
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
            }
            
            setupControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.camera.position.set(5, 8, 5);
                this.controls.update();
            }
            
            setupGrid() {
                const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
                this.scene.add(gridHelper);
            }
            
            addCoordinateSystem() {
                log('üß≠ ADDING MEGA-VISIBLE COORDINATE SYSTEM...');
                
                // Create LARGE coordinate system visualization at origin
                const axesHelper = new THREE.AxesHelper(10);
                this.scene.add(axesHelper);
                
                // X-axis (Red) - HUGE RED CONE
                const xGeometry = new THREE.ConeGeometry(0.5, 1.0, 8);
                const xMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const xCone = new THREE.Mesh(xGeometry, xMaterial);
                xCone.position.set(10.5, 0, 0);
                xCone.rotation.z = -Math.PI / 2;
                this.scene.add(xCone);
                
                // Y-axis (Green) - HUGE GREEN CONE
                const yGeometry = new THREE.ConeGeometry(0.5, 1.0, 8);
                const yMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const yCone = new THREE.Mesh(yGeometry, yMaterial);
                yCone.position.set(0, 10.5, 0);
                this.scene.add(yCone);
                
                // Z-axis (Blue) - HUGE BLUE CONE
                const zGeometry = new THREE.ConeGeometry(0.5, 1.0, 8);
                const zMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                const zCone = new THREE.Mesh(zGeometry, zMaterial);
                zCone.position.set(0, 0, 10.5);
                zCone.rotation.x = Math.PI / 2;
                this.scene.add(zCone);
                
                // White cube at origin
                const originGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const originMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const originCube = new THREE.Mesh(originGeometry, originMaterial);
                originCube.position.set(0, 0, 0);
                this.scene.add(originCube);
                
                log('üî¥ HUGE RED CONE at X-axis (right)');
                log('üü¢ HUGE GREEN CONE at Y-axis (up)');
                log('üîµ HUGE BLUE CONE at Z-axis (forward)');
                log('‚ö™ WHITE CUBE at origin (0,0,0)');
            }
            
            centerCamera() {
                this.camera.position.set(5, 8, 5);
                this.camera.lookAt(0, 0, 0);
                this.controls.update();
                log('üìπ Camera centered');
            }
            
            hexToThreeJSPosition(q, r, elevation = 0) {
                log(`üßÆ HEX-TO-POSITION: hex(${q}, ${r}) ‚Üí Three.js coordinates`);
                
                // Standard hex-to-cartesian conversion for pointy-top hexagons
                const hexX = Math.sqrt(3) * (q + r / 2);
                const hexZ = 3/2 * r;
                
                log(`  Hex math: X = ‚àö3 * (${q} + ${r}/2) = ${hexX.toFixed(3)}`);
                log(`  Hex math: Z = 3/2 * ${r} = ${hexZ.toFixed(3)}`);
                log(`  Y = elevation = ${elevation}`);
                
                const result = new THREE.Vector3(hexX, elevation, hexZ);
                log(`  Result: (${result.x.toFixed(3)}, ${result.y.toFixed(3)}, ${result.z.toFixed(3)})`);
                
                return result;
            }
            
            getMaterial(materialType) {
                switch (materialType) {
                    case 'grass': return new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    case 'water': return new THREE.MeshLambertMaterial({ color: 0x4169E1, transparent: true, opacity: 0.8 });
                    case 'sand': return new THREE.MeshLambertMaterial({ color: 0xF4A460 });
                    case 'stone': return new THREE.MeshLambertMaterial({ color: 0x696969 });
                    case 'road': return new THREE.MeshLambertMaterial({ color: 0x555555 });
                    default: return new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                }
            }
            
            async loadSTL(path, assetPack) {
                const cacheKey = `${path}_${assetPack.id}`;
                if (this.loadedModels.has(cacheKey)) {
                    return this.loadedModels.get(cacheKey).clone();
                }

                const loader = new STLLoader();
                return new Promise((resolve, reject) => {
                    loader.load(path, (geometry) => {
                        log(`\nüîß LOADING STL MODEL: ${path}`);
                        
                        geometry.computeBoundingBox();
                        const originalBounds = geometry.boundingBox;
                        
                        const zSize = originalBounds.max.z - originalBounds.min.z;
                        const xSize = originalBounds.max.x - originalBounds.min.x;
                        const ySize = originalBounds.max.y - originalBounds.min.y;
                        
                        log(`üìè ORIGINAL BOUNDS: X=${xSize.toFixed(3)}, Y=${ySize.toFixed(3)}, Z=${zSize.toFixed(3)}`);
                        
                        if (zSize < Math.max(xSize, ySize) * 0.2) {
                            log(`‚úÖ Geometry is FLAT on XY plane (Z-up orientation)`);
                        } else {
                            log(`‚ö†Ô∏è Geometry appears TALL - might already be Y-up oriented`);
                        }
                        
                        // Center the geometry
                        const center = new THREE.Vector3();
                        geometry.boundingBox.getCenter(center);
                        log(`üìç CENTERING: Translating by (${-center.x.toFixed(3)}, ${-center.y.toFixed(3)}, ${-center.z.toFixed(3)})`);
                        geometry.translate(-center.x, -center.y, -center.z);
                        
                        // Apply coordinate system transformation
                        this.transformGeometry(geometry, assetPack);
                        
                        // Debug transformed bounds
                        geometry.computeBoundingBox();
                        const transformedBounds = geometry.boundingBox;
                        const newZSize = transformedBounds.max.z - transformedBounds.min.z;
                        const newXSize = transformedBounds.max.x - transformedBounds.min.x;
                        const newYSize = transformedBounds.max.y - transformedBounds.min.y;
                        
                        log(`üìè TRANSFORMED BOUNDS: X=${newXSize.toFixed(3)}, Y=${newYSize.toFixed(3)}, Z=${newZSize.toFixed(3)}`);
                        log(`‚úÖ MODEL LOADED AND CACHED\n`);
                        
                        this.loadedModels.set(cacheKey, geometry);
                        resolve(geometry.clone());
                    }, undefined, reject);
                });
            }
            
            transformGeometry(geometry, assetPack) {
                if (!assetPack.geometry_config) {
                    log(`‚ö†Ô∏è NO GEOMETRY CONFIG - skipping transformation`);
                    return;
                }
                
                const config = assetPack.geometry_config;
                
                log(`üîÑ COORDINATE SYSTEM TRANSFORMATION:`);
                log(`  Pack config: tile_up_axis="${config.tile_up_axis}"`);
                log(`  Three.js uses: Y-up (positive Y points UP)`);
                
                if (config.tile_up_axis === 'z+') {
                    log(`  üîÑ TRANSFORM: Pack uses Z-up ‚Üí Three.js uses Y-up`);
                    log(`  üîÑ APPLYING: +90¬∞ rotation around X-axis`);
                    log(`     This rotates XY plane (flat) ‚Üí XZ plane (standing up)`);
                    
                    geometry.rotateX(Math.PI / 2);
                    
                    log(`  ‚úÖ ROTATION APPLIED`);
                } else if (config.tile_up_axis === 'y+') {
                    log(`  ‚úÖ NO TRANSFORM NEEDED - pack already uses Y-up`);
                } else {
                    log(`  ‚ùå UNSUPPORTED tile_up_axis: ${config.tile_up_axis}`);
                }
            }
            
            async renderWorld(world, assetPack) {
                this.worldGroup.clear();
                log(`üé® RENDERING WORLD: ${world.tiles.length} tiles, ${world.addons.length} addons`);
                
                // Render tiles
                for (const worldTile of world.tiles) {
                    await this.renderTile(worldTile, assetPack);
                }
                
                // Render addons
                for (const worldAddon of world.addons) {
                    await this.renderAddon(worldAddon, assetPack);
                }
                
                log(`üéâ WORLD RENDERING COMPLETE`);
            }
            
            async renderTile(worldTile, assetPack) {
                log(`\nüèóÔ∏è RENDERING TILE: ${worldTile.tile_type} at hex(${worldTile.q}, ${worldTile.r}), elevation=${worldTile.elevation}`);
                
                const tileDefinition = assetPack.tiles.find(t => t.id === worldTile.tile_type);
                if (!tileDefinition) {
                    log(`‚ùå Tile definition '${worldTile.tile_type}' not found`);
                    return;
                }

                log(`üì¶ Tile definition found: model="${tileDefinition.model}", material="${tileDefinition.base_material}"`);

                try {
                    const geometry = await this.loadSTL(`assets/${tileDefinition.model}`, assetPack);
                    const material = this.getMaterial(tileDefinition.base_material);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    const position = this.hexToThreeJSPosition(worldTile.q, worldTile.r, worldTile.elevation);
                    mesh.position.copy(position);
                    
                    log(`üéØ FINAL TILE POSITION: (${mesh.position.x.toFixed(3)}, ${mesh.position.y.toFixed(3)}, ${mesh.position.z.toFixed(3)})`);
                    log(`üéØ FINAL TILE ROTATION: (${mesh.rotation.x.toFixed(3)}, ${mesh.rotation.y.toFixed(3)}, ${mesh.rotation.z.toFixed(3)}) radians`);
                    
                    this.worldGroup.add(mesh);
                    log(`‚úÖ TILE ADDED TO SCENE\n`);
                    
                } catch (error) {
                    log(`‚ùå Failed to load tile model: ${error.message}`);
                    // Fallback hex
                    const geometry = new THREE.CylinderGeometry(1, 1, 0.1, 6);
                    const material = this.getMaterial(tileDefinition.base_material);
                    const mesh = new THREE.Mesh(geometry, material);
                    const position = this.hexToThreeJSPosition(worldTile.q, worldTile.r, worldTile.elevation);
                    mesh.position.copy(position);
                    this.worldGroup.add(mesh);
                    log(`‚ö†Ô∏è Used fallback geometry for tile: ${worldTile.tile_type}`);
                }
            }
            
            async renderAddon(worldAddon, assetPack) {
                const addonDefinition = assetPack.addons.find(a => a.id === worldAddon.addon_id);
                if (!addonDefinition) {
                    log(`‚ùå Addon definition '${worldAddon.addon_id}' not found`);
                    return;
                }
                
                try {
                    const geometry = await this.loadSTL(`assets/${addonDefinition.model}`, assetPack);
                    
                    let materialType = 'grass';
                    if (addonDefinition.tags.includes('tree')) materialType = 'grass';
                    else if (addonDefinition.tags.includes('rock')) materialType = 'stone';
                    
                    const material = this.getMaterial(materialType);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    
                    const tilePosition = this.hexToThreeJSPosition(worldAddon.q, worldAddon.r, 0);
                    
                    // Handle local position offsets
                    const config = assetPack.geometry_config;
                    let offsetX, offsetY, offsetZ;
                    
                    if (config?.tile_up_axis === 'z+') {
                        // Pack coordinates: [x, y, z] -> Three.js coordinates: [x, z, y]
                        offsetX = worldAddon.local_position[0];
                        offsetY = worldAddon.local_position[2]; // Pack Z becomes Three.js Y
                        offsetZ = worldAddon.local_position[1]; // Pack Y becomes Three.js Z
                    } else {
                        offsetX = worldAddon.local_position[0];
                        offsetY = worldAddon.local_position[1];
                        offsetZ = worldAddon.local_position[2];
                    }
                    
                    mesh.position.set(
                        tilePosition.x + offsetX,
                        tilePosition.y + offsetY,
                        tilePosition.z + offsetZ
                    );
                    
                    mesh.rotation.y = THREE.MathUtils.degToRad(worldAddon.local_rotation);
                    mesh.scale.setScalar(worldAddon.local_scale);
                    
                    this.worldGroup.add(mesh);
                    log(`‚úÖ Rendered addon: ${worldAddon.addon_id} at (${worldAddon.q}, ${worldAddon.r})`);
                } catch (error) {
                    log(`‚ùå Failed to load addon model: ${error.message}`);
                }
            }
            
            onWindowResize() {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        let renderer = null;

        async function initializeRenderer() {
            try {
                log('üöÄ INITIALIZING WORKING HEX RENDERER...');
                
                const container = document.getElementById('renderer');
                renderer = new WorkingHexRenderer(container);
                
                return true;
            } catch (error) {
                log(`‚ùå RENDERER INIT ERROR: ${error.message}`);
                console.error('Renderer initialization failed:', error);
                return false;
            }
        }

        async function loadDemoWorld() {
            const loading = document.getElementById('loading');
            
            if (!renderer) {
                log('‚ùå Renderer not initialized!');
                return;
            }
            
            try {
                loading.style.display = 'block';
                log('üì¶ LOADING DEMO WORLD...');
                
                // Load asset pack
                const assetPackResponse = await fetch('assets/demo-pack.json');
                if (!assetPackResponse.ok) {
                    throw new Error(`Failed to fetch asset pack: ${assetPackResponse.status}`);
                }
                const assetPack = await assetPackResponse.json();
                log(`‚úÖ Asset pack loaded: ${assetPack.name}`);
                log(`üß≠ Geometry config: tile_up_axis="${assetPack.geometry_config.tile_up_axis}"`);
                
                // Load world
                const worldResponse = await fetch('assets/demo-world.json');
                if (!worldResponse.ok) {
                    throw new Error(`Failed to fetch world: ${worldResponse.status}`);
                }
                const world = await worldResponse.json();
                log(`‚úÖ World data loaded: ${world.tiles.length} tiles, ${world.addons.length} addons`);
                
                // Render world
                await renderer.renderWorld(world, assetPack);
                
                // Update info panel
                document.getElementById('tileCount').textContent = `Tiles: ${world.tiles.length}`;
                document.getElementById('addonCount').textContent = `Addons: ${world.addons.length}`;
                document.getElementById('assetPack').textContent = `Asset Pack: ${assetPack.name}`;
                document.getElementById('worldInfo').style.display = 'block';
                
                log('üéâ DEMO WORLD LOADED SUCCESSFULLY!');
                log('üß≠ Look for the HUGE colored cones showing coordinate system!');
                
            } catch (error) {
                log(`‚ùå DEMO LOAD ERROR: ${error.message}`);
                console.error('Failed to load demo:', error);
            } finally {
                loading.style.display = 'none';
            }
        }

        // Event listeners
        document.getElementById('loadDemo').addEventListener('click', loadDemoWorld);
        
        document.getElementById('centerCamera').addEventListener('click', () => {
            if (renderer) {
                renderer.centerCamera();
            }
        });
        
        document.getElementById('toggleGrid').addEventListener('click', () => {
            log('‚äû Grid toggle (functionality not implemented in this demo)');
        });

        // Initialize everything
        log('üåç WORKING HEX3WORLD LOADING...');
        initializeRenderer().then(success => {
            if (success) {
                log('‚úÖ READY! Click "Load Demo World" to test.');
                // Auto-load demo after a short delay
                setTimeout(() => {
                    log('üöÄ AUTO-LOADING DEMO WORLD...');
                    loadDemoWorld();
                }, 2000);
            } else {
                log('‚ùå INITIALIZATION FAILED!');
            }
        });
    </script>
</body>
</html>