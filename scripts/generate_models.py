#!/usr/bin/env python3
"""
Generate simple 3D models for the hex world demo.
Creates STL files for tiles and addons.
"""

import numpy as np
import math
import struct

def write_stl_binary(filename, vertices, faces):
    """Write STL file in binary format"""
    with open(filename, 'wb') as f:
        # Header (80 bytes)
        header = b'Generated by hex3world demo' + b'\0' * (80 - 28)
        f.write(header)
        
        # Number of triangles
        f.write(struct.pack('<I', len(faces)))
        
        # Write each triangle
        for face in faces:
            # Calculate normal with error handling
            try:
                v1 = vertices[face[1]] - vertices[face[0]]
                v2 = vertices[face[2]] - vertices[face[0]]
                normal = np.cross(v1, v2)
                norm_length = np.linalg.norm(normal)
                if norm_length > 0:
                    normal = normal / norm_length
                else:
                    normal = np.array([0.0, 0.0, 1.0])  # Default normal
            except:
                normal = np.array([0.0, 0.0, 1.0])  # Default normal
            
            # Write normal
            f.write(struct.pack('<fff', float(normal[0]), float(normal[1]), float(normal[2])))
            
            # Write vertices
            for vertex_idx in face:
                vertex = vertices[vertex_idx]
                f.write(struct.pack('<fff', float(vertex[0]), float(vertex[1]), float(vertex[2])))
            
            # Attribute byte count (2 bytes, usually 0)
            f.write(struct.pack('<H', 0))

def create_hexagon_vertices(radius=1.0, height=0.1):
    """Create vertices for a hexagonal prism"""
    vertices = []
    
    # Bottom hexagon vertices
    for i in range(6):
        angle = i * math.pi / 3  # 60 degrees
        x = radius * math.cos(angle)
        y = radius * math.sin(angle)
        vertices.append([x, y, 0])
    
    # Top hexagon vertices
    for i in range(6):
        angle = i * math.pi / 3
        x = radius * math.cos(angle)
        y = radius * math.sin(angle)
        vertices.append([x, y, height])
    
    # Center vertices for top and bottom
    vertices.append([0, 0, 0])      # Bottom center (index 12)
    vertices.append([0, 0, height]) # Top center (index 13)
    
    return np.array(vertices)

def create_hexagon_faces():
    """Create faces for a hexagonal prism"""
    faces = []
    
    # Bottom face (triangular fan from center)
    for i in range(6):
        faces.append([12, (i + 1) % 6, i])  # Reversed winding
    
    # Top face (triangular fan from center)
    for i in range(6):
        faces.append([13, i + 6, (i + 1) % 6 + 6])  # Correct winding
    
    # Side faces (two triangles per side)
    for i in range(6):
        next_i = (i + 1) % 6
        # Triangle 1
        faces.append([i, next_i, i + 6])
        # Triangle 2
        faces.append([next_i, next_i + 6, i + 6])
    
    return faces

def create_grass_hex():
    """Create a grass hexagon tile"""
    vertices = create_hexagon_vertices(radius=1.0, height=0.05)
    faces = create_hexagon_faces()
    return vertices, faces

def create_water_hex():
    """Create a water hexagon tile (slightly lower)"""
    vertices = create_hexagon_vertices(radius=1.0, height=0.02)
    faces = create_hexagon_faces()
    return vertices, faces

def create_sand_hex():
    """Create a sand hexagon tile"""
    vertices = create_hexagon_vertices(radius=1.0, height=0.03)
    faces = create_hexagon_faces()
    return vertices, faces

def create_road_hex():
    """Create a hexagon with a road running through it"""
    # Base hexagon
    vertices = create_hexagon_vertices(radius=1.0, height=0.05)
    faces = create_hexagon_faces()
    
    # Add road strip (simple raised rectangle)
    road_width = 0.3
    road_height = 0.01
    
    # Road vertices (rectangle from one side to opposite)
    road_verts = [
        [-1.0, -road_width/2, 0.05],  # 14
        [1.0, -road_width/2, 0.05],   # 15
        [1.0, road_width/2, 0.05],    # 16
        [-1.0, road_width/2, 0.05],   # 17
        [-1.0, -road_width/2, 0.05 + road_height],  # 18
        [1.0, -road_width/2, 0.05 + road_height],   # 19
        [1.0, road_width/2, 0.05 + road_height],    # 20
        [-1.0, road_width/2, 0.05 + road_height],   # 21
    ]
    
    vertices = np.vstack([vertices, road_verts])
    
    # Add road faces
    road_faces = [
        # Bottom
        [14, 16, 15], [14, 17, 16],
        # Top  
        [18, 19, 20], [18, 20, 21],
        # Sides
        [14, 15, 19], [14, 19, 18],
        [15, 16, 20], [15, 20, 19],
        [16, 17, 21], [16, 21, 20],
        [17, 14, 18], [17, 18, 21],
    ]
    
    faces.extend(road_faces)
    return vertices, faces

def create_shore_hex():
    """Create a shore hexagon (half sand, half water level)"""
    vertices = create_hexagon_vertices(radius=1.0, height=0.04)
    faces = create_hexagon_faces()
    
    # Modify some vertices to create water level on one side
    for i in [2, 3, 4]:  # Bottom half vertices
        vertices[i][2] = 0.01  # Lower water level
        vertices[i + 6][2] = 0.01  # Top vertices too
    
    return vertices, faces

def create_simple_tree():
    """Create a simple tree (cylinder trunk + sphere leaves)"""
    vertices = []
    faces = []
    
    # Trunk (cylinder)
    trunk_radius = 0.05
    trunk_height = 0.3
    trunk_segments = 8
    
    # Trunk bottom circle
    for i in range(trunk_segments):
        angle = i * 2 * math.pi / trunk_segments
        x = trunk_radius * math.cos(angle)
        y = trunk_radius * math.sin(angle)
        vertices.append([x, y, 0])
    
    # Trunk top circle
    for i in range(trunk_segments):
        angle = i * 2 * math.pi / trunk_segments
        x = trunk_radius * math.cos(angle)
        y = trunk_radius * math.sin(angle)
        vertices.append([x, y, trunk_height])
    
    # Trunk centers
    vertices.append([0, 0, 0])  # Bottom center
    vertices.append([0, 0, trunk_height])  # Top center
    
    # Trunk faces
    # Bottom
    for i in range(trunk_segments):
        faces.append([trunk_segments * 2, i, (i + 1) % trunk_segments])
    
    # Top
    for i in range(trunk_segments):
        faces.append([trunk_segments * 2 + 1, (i + 1) % trunk_segments + trunk_segments, i + trunk_segments])
    
    # Sides
    for i in range(trunk_segments):
        next_i = (i + 1) % trunk_segments
        faces.append([i, i + trunk_segments, next_i])
        faces.append([next_i, i + trunk_segments, next_i + trunk_segments])
    
    # Leaves (simple icosphere approximation)
    leaves_center = [0, 0, trunk_height + 0.15]
    leaves_radius = 0.2
    leaves_start_idx = len(vertices)
    
    # Add some vertices around the sphere
    phi_steps = 6
    theta_steps = 4
    
    for i in range(phi_steps):
        phi = i * 2 * math.pi / phi_steps
        for j in range(theta_steps):
            theta = j * math.pi / theta_steps
            x = leaves_radius * math.sin(theta) * math.cos(phi)
            y = leaves_radius * math.sin(theta) * math.sin(phi)
            z = leaves_radius * math.cos(theta) + leaves_center[2]
            vertices.append([x, y, z])
    
    # Simple sphere faces (approximate)
    for i in range(phi_steps):
        for j in range(theta_steps - 1):
            idx = leaves_start_idx + i * theta_steps + j
            next_phi = leaves_start_idx + ((i + 1) % phi_steps) * theta_steps + j
            
            faces.append([idx, next_phi, idx + 1])
            faces.append([idx + 1, next_phi, next_phi + 1])
    
    return np.array(vertices), faces

def create_small_rock():
    """Create a small rock (irregular shape)"""
    vertices = []
    faces = []
    
    # Create an irregular rock shape
    base_vertices = [
        [0.1, 0.1, 0],
        [-0.1, 0.15, 0],
        [-0.15, -0.1, 0],
        [0.12, -0.12, 0],
        [0.05, -0.05, 0.1],
        [-0.05, 0.08, 0.08],
        [-0.08, -0.05, 0.12],
        [0.08, -0.02, 0.09],
    ]
    
    vertices = np.array(base_vertices)
    
    # Create faces manually for the rock
    faces = [
        [0, 1, 4], [1, 5, 4], [1, 2, 5], [2, 6, 5],
        [2, 3, 6], [3, 7, 6], [3, 0, 7], [0, 4, 7],
        [4, 5, 6], [4, 6, 7], [0, 2, 1], [0, 3, 2]
    ]
    
    return vertices, faces

def main():
    """Generate all demo models"""
    models_dir = "/Users/somogyijanos/Repos/tiny/hex3world/assets/models/"
    
    print("Generating 3D models...")
    
    # Tile models
    models = [
        ("grass_hex.stl", create_grass_hex),
        ("water_hex.stl", create_water_hex),
        ("sand_hex.stl", create_sand_hex),
        ("road_hex.stl", create_road_hex),
        ("shore_hex.stl", create_shore_hex),
        ("simple_tree.stl", create_simple_tree),
        ("small_rock.stl", create_small_rock),
    ]
    
    for filename, create_func in models:
        print(f"Creating {filename}...")
        vertices, faces = create_func()
        write_stl_binary(models_dir + filename, vertices, faces)
    
    print("All models generated successfully!")

if __name__ == "__main__":
    main()